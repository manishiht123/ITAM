const fs   = require("fs");
const path = require("path");
const sequelize = require("../config/db");

// ── CSV helpers ───────────────────────────────────────────────────────────────

/**
 * Parse a single CSV line, handling double-quoted fields.
 */
function parseCSVLine(line) {
  const fields = [];
  let i = 0, current = "";
  while (i < line.length) {
    if (line[i] === '"') {
      i++;
      while (i < line.length) {
        if (line[i] === '"' && line[i + 1] === '"') { current += '"'; i += 2; }
        else if (line[i] === '"') { i++; break; }
        else { current += line[i++]; }
      }
    } else if (line[i] === ",") {
      fields.push(current);
      current = "";
      i++;
    } else {
      current += line[i++];
    }
  }
  fields.push(current);
  return fields;
}

// ── SQL restore ───────────────────────────────────────────────────────────────

/**
 * Restore from a .sql dump file generated by backupService.dumpDatabase().
 * Executes each statement individually so failures are isolated.
 */
async function restoreFromSQL(filePath) {
  const content  = fs.readFileSync(filePath, "utf8");

  // Accumulate lines into statements — a statement ends when a line ends with ';'
  const statements = [];
  let current = "";
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("--")) continue; // skip blanks & comments
    current += (current ? "\n" : "") + line;
    if (trimmed.endsWith(";")) {
      const stmt = current.trim().replace(/;$/, "").trim();
      if (stmt) statements.push(stmt);
      current = "";
    }
  }

  let restored = 0, skipped = 0;
  for (const stmt of statements) {
    if (!stmt) continue;
    try {
      await sequelize.query(stmt);
      restored++;
    } catch (err) {
      // DROP TABLE for a non-existent table is safe to skip
      if (err.message.includes("Unknown table") || err.message.includes("doesn't exist")) {
        skipped++;
      } else {
        throw err;
      }
    }
  }
  return { statementsRestored: restored, statementsSkipped: skipped };
}

// ── CSV restore ───────────────────────────────────────────────────────────────

/**
 * Restore from a CSV backup directory created by backupService.exportCsv().
 * Clears each table then re-inserts rows from the CSV.
 */
async function restoreFromCSV(dirPath) {
  const manifestPath = path.join(dirPath, "_manifest.json");
  if (!fs.existsSync(manifestPath)) {
    throw new Error("Invalid CSV backup — _manifest.json not found.");
  }

  const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
  const tables   = manifest.tables || [];
  const results  = [];

  await sequelize.query("SET FOREIGN_KEY_CHECKS = 0");
  try {
    for (const filename of tables) {
      const tableName = filename.replace(".csv", "");
      const csvPath   = path.join(dirPath, filename);

      if (!fs.existsSync(csvPath)) {
        results.push({ table: tableName, status: "skipped", reason: "File not found" });
        continue;
      }

      const lines = fs.readFileSync(csvPath, "utf8").split("\n").filter(l => l.trim());
      if (lines.length < 2) {
        results.push({ table: tableName, status: "skipped", reason: "No data rows" });
        continue;
      }

      const headers = parseCSVLine(lines[0]);
      try {
        await sequelize.query(`DELETE FROM \`${tableName}\``);

        let inserted = 0;
        for (let i = 1; i < lines.length; i++) {
          const values = parseCSVLine(lines[i]);
          if (values.length !== headers.length) continue;

          const colList = headers.map(h => `\`${h}\``).join(", ");
          const valList = values.map(v =>
            (v === "" || v === "NULL")
              ? "NULL"
              : `'${v.replace(/\\/g, "\\\\").replace(/'/g, "\\'")}' `
          ).join(", ");

          await sequelize.query(
            `INSERT INTO \`${tableName}\` (${colList}) VALUES (${valList})`
          );
          inserted++;
        }
        results.push({ table: tableName, status: "success", rows: inserted });
      } catch (err) {
        results.push({ table: tableName, status: "error", reason: err.message });
      }
    }
  } finally {
    await sequelize.query("SET FOREIGN_KEY_CHECKS = 1");
  }
  return results;
}

module.exports = { restoreFromSQL, restoreFromCSV };
